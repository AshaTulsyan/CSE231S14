This analysis is again performed in an intra-procedural manner. The theoretical background for this analysis has been covered in class so we will not analyze it further in this report. Instead, we will describe how we managed to implement the flow-functions, the lattices and the actual flow representation. 


\subsection{Lattice, Flow \& Flow Functions}
As previously described, we once again utilize stl maps to represent the in and out flow of each statement. However, since this is a constant propagation analysis the domain is different. Specifically, the domain is: D = Powerset($\{x\ra c|x\in vars \wedge c\in constants\}$). Therefore, we are using a map that uses a string as a key to keep the name of the register and a float as a value to keep the constant that this register points to. We didn't have to generate a representation for the lattice since it's implicitly described by our flow functions and the implemented methods in the Flow class. 

More precisely, inside the Constant Propagation Flow class, we had to override the functions described in the section where we analyzed our framework. Since most of the changes we performed on the functions from one analysis to another are more or less straight forward, we would like to focus on the join method since this is the most interesting one. Before, we go any further we should clarify that this method does not implement the join-merging method described in theory, the actual join will be performed when we reach the phi node, because only at that point we will know exactly which are the variables we are trying to merge, for now we just need to union the information gained by the branches, so that it would be available when we reach the phi node. Specifically, if one of the two input flows is set to top, then the result of the join will also be top, if both of the input flows are set to bottom then the output flow is also bottom. However if only one of the input flows are set to bottom then the output is going to be identical to the other input flow. Lastly, if the two flows have different maps then the output will include all the mappings described in the input flows. 

\subsection*{Stack-Allocated Variables to Registers, SSA and Merging}

At this point we should mention that we run this analysis on the output of mem2reg pass. When the bitcode of a program is generated by LLVM it  treats local variables as stack-allocated variables, so every read and write is actually translated into memory loads and stores. However, this is not very useful for our analysis because we need to have an actual representation for each variable. In order to achieve that, we perform the mem2reg pass to our generated bitcode which promotes stack-allocated variables to registers when it is safe to do so. Therefore, we end up having assignments into registers, so for each analysis that requires an actual representation of a variable (not a pointer), we perform this pass first. 

Additionally, mem2reg pass performs SSA (static single assignment form) and a very basic and limited constant propagation. SSA is a property of an intermediate representation which requires that each variable (register in our case) is assigned exactly once and every variable is defined before it is used. Essentially, this can be viewed in listing \ref{SSA}. One interesting fact that can be viewed in this listing is that while the initial C++ code assigns the result of the addition of 5 and 15 to variable c, the LLVM assumes that these variables correspond to three different registers, so since we are performing constant propagation all of these registers should point to number 20. Another interesting note is that according to the lecture notes, in constant propagation if we try to re-assign a variable, (say: c) to another constant, we would have to delete every occurrence of \{$c\ra* \in$in\}, but now we don't. There are two reasons why we don't have to deal with that, the first one is that we are using a map to represent these assignments so when we re-assign the value of a specific key it gets overwritten by default, (unlike sets) and secondly because due to SSA, we don't have to consider special cases. 


Let's take a glance at another example that points that out. If we have a look at listing \ref{SSAFF} we'll notice that we have a similar example as before, but this time we also have an if-then-else statement that contains the set of assignments. By looking at the ll code, we'll notice that registers \%add and \%add1 are assigned inside the taken branch but they are not used by the phi node when merging so they cannot be detected and therefore they cannot be deleted, but that doesn't cause any issues, because due to SSA they will not be re-written again. If they get reused by reading the value from those registers their actual value is going to be the one we kept, if we assigned another value to these registers (which only happen in a loop) then as we mentioned earlier by re-assigning a new value to a key that already appears we basically delete and re-write this particular key, so there is nothing that could go wrong.

Now let's talk about the merging. Things are really straight forward for the key: \%c.0, both \%add2 and \%add4 have the same value (20), in this example so we will just assign this value to \%c.0, but this is not the case for \%d.0, since \%add3 and \%add5 have different values (namely: 30 and 29), we will not propagate any value to this register, additionally the details that held true for registers \%add and \%add1 hold true for the rest of the registers that have an assigned value so we don't have to delete them. 


\begin{lstlisting}[caption=SSA preview, label=SSA]
// ... Piece of C++ code ...
c = 5+15;
c = 5+15;
c = 5+15;

// ... Coresponding LL code after ...
// ... mem2reg has been applied   ...

%add = add nsw i32 5, 15
%add1 = add nsw i32 5, 15
%add2 = add nsw i32 5, 15

\end{lstlisting}

\begin{lstlisting}[caption=SSA within a branch preview, label=SSAFF]

// ... Another piece of C++ code ...
  if(statement){
	  c = a+b;
	  c = a+b;
	  c = a+b;
	  d = c+10;
  }
  else{
	  c = a+b;
	  d = c+9;
  }

// ... Coresponding LL code after ...
// ... mem2reg has been applied   ...

if.then:                                          ; preds = %entry
  %add = add nsw i32 5, 15
  %add1 = add nsw i32 5, 15
  %add2 = add nsw i32 5, 15
  %add3 = add nsw i32 %add2, 10
  br label %if.end

if.else:                                          ; preds = %entry
  %add4 = add nsw i32 5, 15
  %add5 = add nsw i32 %add4, 9
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %c.0 = phi i32 [ %add2, %if.then ], 
         [ %add4, %if.else ]
  %d.0 = phi i32 [ %add3, %if.then ], 
         [ %add5, %if.else ]

  \end{lstlisting}
  
  
\subsection*{Supported Flow Functions}
While, the majority of the teams only support integers and therefore they have only implemented a very small set of flow functions, we went one step further, by supporting different types of variables and therefore more opcodes and flow-functions. Specifically, we cover all the standard binary operators (opcodes:8-19), all the logical operators (opcodes: 20-25), all the cast operators that can be used on registers (opcodes:33-41) and of course phi nodes (opcode 48). 



\subsection*{Interesting Notes - Comments}
Some interesting notes here are the following:



\begin{itemize}

  \item Firstly, while we were trying to perform the flow function for the division (the operators for the different kinds of the divisions are: UDiv, SDiv and FDiv) we were thinking that we probably had to check if the divisor is equal to zero and print an error message in this case. As it turns out we don't have to because we are using floats to represent every number internally and in C++ diving floats with zero returns +/- inf.
  \item Secondly, we should mention that we had to include casts because of occasions like the sample program shown in listing \ref{casting}. In this example, we assume that 5 and 15 are floats but variable c is an integer, therefore we have to cast before we actually assign the result of the summation to c (or to be precise, to \%conv). The conclusion is that if we decide to support instructions with different types of variables then we have to support casts.
  
  \item Thirdly, while mem2reg usually outputs instructions like the one shown above where the register names are actual strings, we had some issues when we tried to run our passes on a mac. Particularly, instead of having registers like \%add3, \%sub1 and so on we had \%1, \%2 \ldots Which caused problems in our analyses. That probably happened because another LLVM/Clang version was installed on that machine but it can be easily solved if we added the flag -instnamer to our mem2reg pass.

\end{itemize}


\begin{lstlisting}[caption=value preservation inside casts, label=casting]
// ... Piece of C++ code ...
int c = 5.0f+15.0f;


// ... Coresponding LL code ...

 %add = fadd float 5.000000e+00, 1.500000e+01
 %conv = fptosi float %add to i32

\end{lstlisting}







  