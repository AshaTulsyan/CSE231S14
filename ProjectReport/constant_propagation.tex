This analysis is again performed in an intra-procedural manner. The theoretical background for this analysis has been covered in class so we will not analyze it further in this report. Instead, we will describe how we managed to implement the flow-functions, the lattices and the actual flow representation. 


\subsection{Lattice, Flow \& Flow Functions}
As previously described, we once again utilize stl maps to represent the in and out flow of each statement. However, since this is a constant propagation analysis the domain is different. Specifically, the domain is: D = Powerset($\{x\ra c|x\in vars \wedge c\in constants\}$). Therefore, we are using a map that has a string as a key to keep the name of the register and a float as value to keep the constants that this register points to. We didn't have to generate a representation for the lattice since it's implicitly described by our flow functions and the implemented methods in the Flow class. 

More precisely, inside the Constant Propagation Flow class, we had to override the functions described above in the section where we analyzed our framework. Since most of the changes we performed on the functions from one analysis to the other are more or less straight forward, we would like to focus on the join method since this is the most interesting one. Before, we go any further we should clarify that this method does not implement the join method described in theory, the actual join will be performed when we reach the phi node, because only at that point we will know exactly which are the variables we are trying to merge, for now we just need to union the information gained by the branches, so that it would be available when we reach the phi node. Specifically, if one of the two input flows is set to top, then the result of the join will also be top, if both of the input flows are set to bottom then the output flow is also bottom. However if only one of the input flows are set to bottom then the output is going to be identical to the other input flow. Lastly, if the two flows have different maps then the output will include all the mappings described in the input flows. 

At this point we should mention that we run this analysis on the output of mem2reg pass. When the bitcode is generated by LLVM for a program, it  treats local variables as stack-allocated variables, so every read and write is actually translated into memory loads and stores. However, this is not very useful for our analysis because we need to have an actual representation for each variable. In order to achieve that, we perform a mem2reg pass which promotes stack-allocated variables to registers when it is safe to do so. Therefore, we end up having assignments into registers, so for each analysis that requires an actual representation for a variable (not a pointer), we perform this pass first. 

Additionally, mem2reg pass performs SSA (static single assignment form). SSA is a property of an intermediate representation which requires that each variable (register in our case) is assigned exactly once and every variable is defined before it is used. Essentially, this can be viewed in listing \ref{SSA}. One interesting fact that can be viewed in this listing is that while the initial C++ code assigns the result of the addition of 5 and 15 to variable c, the LLVM assumes that these variables correspond to three different registers, so since we are performing constant propagation all of these registers should point to number 20. Another interesting note is that according to the lecture notes, in constant propagation if we try to re-assign a variable, (say: c) to another constant, we would have to delete every occurrence of $c\ra*$in the in set, but now we don't. There are two reasons why we don't have to deal with that, the first one is that we are using a map to represent these assignments so when we re-assign the value of a specific key it gets overwritten by default and secondly because 




\begin{lstlisting}[caption=SSA preview, label=SSA]
// ... Piece of C++ code ...
c = 5+15;
c = 5+15;
c = 5+15;

// ... Transformated LL code ...

%add = add nsw i32 5, 15
%add1 = add nsw i32 5, 15
%add2 = add nsw i32 5, 15

\end{lstlisting}


