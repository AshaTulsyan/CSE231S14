This analysis is again performed in an intra-procedural manner. The theoretical background for this analysis has been covered in class so we will not analyze it further in this report. Instead, we will describe how we managed to implement the flow-functions, the lattices and the actual flow representation. 


\subsection{Lattice, Flow \& Flow Functions}
As previously described, we once again utilize stl maps to represent the in and out flow of each statement. However, since this is a constant propagation analysis the domain is different. Specifically, the domain is: D = Powerset($\{x\ra c|x\in vars \wedge c\in constants\}$). Therefore, we are using a map that uses a string as a key to keep the name of the register and a float as a value to keep the constants that this register points to. We didn't have to generate a representation for the lattice since it's implicitly described by our flow functions and the implemented methods in the Flow class. 

More precisely, inside the Constant Propagation Flow class, we had to override the functions described in the section where we analyzed our framework. Since most of the changes we performed on the functions from one analysis to another are more or less straight forward, we would like to focus on the join method since this is the most interesting one. Before, we go any further we should clarify that this method does not implement the join-merging method described in theory, the actual join will be performed when we reach the phi node, because only at that point we will know exactly which are the variables we are trying to merge, for now we just need to union the information gained by the branches, so that it would be available when we reach the phi node. Specifically, if one of the two input flows is set to top, then the result of the join will also be top, if both of the input flows are set to bottom then the output flow is also bottom. However if only one of the input flows are set to bottom then the output is going to be identical to the other input flow. Lastly, if the two flows have different maps then the output will include all the mappings described in the input flows. 

\subsubsection*{Stack-Allocated Variables to Registers, SSA and Merging}

At this point we should mention that we run this analysis on the output of mem2reg pass. When the bitcode of a program is generated by LLVM it  treats local variables as stack-allocated variables, so every read and write is actually translated into memory loads and stores. However, this is not very useful for our analysis because we need to have an actual representation for each variable. In order to achieve that, we perform the mem2reg pass to our generated bitcode which promotes stack-allocated variables to registers when it is safe to do so. Therefore, we end up having assignments into registers, so for each analysis that requires an actual representation of a variable (not a pointer), we perform this pass first. 

Additionally, mem2reg pass performs SSA (static single assignment form) and a very basic and limited constant propagation. SSA is a property of an intermediate representation which requires that each variable (register in our case) is assigned exactly once and every variable is defined before it is used. Essentially, this can be viewed in listing \ref{SSA}. One interesting fact that can be viewed in this listing is that while the initial C++ code assigns the result of the addition of 5 and 15 to variable c, the LLVM assumes that these variables correspond to three different registers, so since we are performing constant propagation all of these registers should point to number 20. Another interesting note is that according to the lecture notes, in constant propagation if we try to re-assign a variable, (say: c) to another constant, we would have to delete every occurrence of \{$c\ra*$in\} in the input set, but now we don't. There are two reasons why we don't have to deal with that, the first one is that we are using a map to represent these assignments so when we re-assign the value of a specific key it gets overwritten by default and secondly because due to SSA, we don't have to. 


Let's have a look at another example that points that out. If we have a look at listing \ref{SSAFF} we'll notice that we have a similar example as before, but this time we also have an if-then-else statement that contains the set of assignments. By looking at the ll code, we'll notice that registers \%add and \%add1 are assigned inside the taken branch but they are not used from the phi node while merging so they cannot be spotted and therefore they cannot be deleted, but that doesn't cause any issues, because due to SSA they will not be re-written again but even if they get reused by reading the value from those registers their actual value is going to be the one that we kept, if we assigned another value to these registers (which will not happen) then as we mentioned earlier by re-assigning a new value to a key that already appears we basically delete and re-write this particular key, so there is nothing that could go wrong.

Now let's talk about the merging. Things are really straight forward for \%c.0, both \%add2 and \%add4 have the same value (20), in this example so we will just assign this value to \%c.0, but this is not the case for \%d.0, since \%add3 and \%add5 have different values (namely: 30 and 29), we will not propagate any value to this register, additionally the details that held true for registers \%add and \%add1 hold true for the rest of the registers that have an assigned value so we don't have to delete them. 


\begin{lstlisting}[caption=SSA preview, label=SSA]
// ... Piece of C++ code ...
c = 5+15;
c = 5+15;
c = 5+15;

// ... Coresponding LL code after mem2reg has been applied ...

%add = add nsw i32 5, 15
%add1 = add nsw i32 5, 15
%add2 = add nsw i32 5, 15

\end{lstlisting}

\begin{lstlisting}[caption=SSA preview, label=SSAFF]

// ... Another piece of C++ code ...
  if(statement){
	  c = a+b;
	  c = a+b;
	  c = a+b;
	  d = c+10;
  }
  else{
	  c = a+b;
	  d = c+9;
  }

// ... Coresponding LL code after mem2reg has been applied ...

if.then:                                          ; preds = %entry
  %add = add nsw i32 5, 15
  %add1 = add nsw i32 5, 15
  %add2 = add nsw i32 5, 15
  %add3 = add nsw i32 %add2, 10
  br label %if.end

if.else:                                          ; preds = %entry
  %add4 = add nsw i32 5, 15
  %add5 = add nsw i32 %add4, 9
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %c.0 = phi i32 [ %add2, %if.then ], [ %add4, %if.else ]
  %d.0 = phi i32 [ %add3, %if.then ], [ %add5, %if.else ]

  \end{lstlisting}