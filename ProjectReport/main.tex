\documentclass[11pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{color}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage[noend,linesnumbered]{algorithm2e}
\usepackage{setspace} 
\usepackage{enumerate} 
\usepackage{amsthm}
\newcommand{\lra}{\Leftrightarrow}
\newcommand{\join}{\bowtie}
\newcommand{\select}{\sigma}
\newcommand{\project}{\pi}
\newcommand{\distinct}{\delta}
\newcommand{\Schema}{\Sigma}
\newcommand{\ra}{\rightarrow}
\newcommand{\q}{\quad}
\newcommand{\tbf}{\textbf}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}


\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\usepackage{amssymb}

\let\oldemptyset\emptyset
\let\emptyset\varnothing

\newcommand\NV[1]{**NV #1 ** }
\newcommand{\code}{\lstinline}



\begin{document}

\title{Project Report}
\author{Konstantinos Zarifis \quad Jules Testard \quad Michael Barrow}
\maketitle

\section{Introduction}

\input{introduction}

\section{The interface}

We have designed the interface with the client analysis developper in mind.
It is built to be clear, understandable, easy to use and easy to extend. The focus has been put on clarity and extensibility rather than performance. Indeed, to build a basic client analysis, only two classes have to be extended and five short virtual methods overridden. We go over each component of the interface implementation. For each component, we describe how a client can use the interface and quickly build his own analysis.

\subsection{The Context Flow Graph}
The first aspect of the dataflow analysis we implemented was its internal representation, the context flow graph.
We wanted to model our dataflow analysis following closely the pseudo code found in the lecture notes. We noticed that the LLVM library provided its own graph implementation in the form of \code{BasicBlocks} and \code{Instructions}. However, we found the stucture of the LLVM library graph too complex and it did not offer the possibility to store the analysis information (which we call \emph{flow}) within. Therefore, we created our own graph structure which is defined in listing \ref{CFG}.

\begin{lstlisting}[caption=Context Flow Graph, label=CFG]
typedef struct ListNode {
  int index;
  vector<ListEdge*> incoming;
  vector<ListEdge*> outgoing;
  Instruction *inst;
  ListNode(int idx){
    index = idx;
  }
} ListNode;

typedef struct ListEdge{
  Flow* flow;
  ListNode* source;
  ListNode* destination;
  ListEdge(ListNode* src, ListNode* dst){
    source = src;
    destination = dst;
    flow = new Flow();
  }
} 
\end{lstlisting}

Each node can have multiple incoming and outgoing edges and represents an instruction in the program. An index has been added to more easily identify the instruction within the program. However, the flow is store only in the edges, in accordance with the algorithm seen in the lecture notes. A convenient method allows the user to display the graph in \code{JSON} format. Finally, the clients do not need to be aware of the graph structure, as it is only used by the class they are going to extend.

\subsection{The Flow Class}

The Flow class is the way we represent the information computed by analyses which use our interface. Any client must create his own class which will extend the flow class. The class 

\begin{itemize}
\item TOP
\item BOTTOM
\item join(Flow* other)
\item equals(Flow* other)
\item copy(Flow* other)
\item jsonString()
\end{itemize}


\subsection{The Static Analysis Class}

The dataflow analysis implementation is centered around the \tbf{worklist algorithm}, whose C++ implementation can be seen on listing \ref{worklist}.

\begin{lstlisting}[caption=Worklist Algorithm, label=worklist]
void StaticAnalysis::runWorklist() {
  queue<ListNode*> worklist;
  
  initializeEdgeFlowToBottom();
  addAllNodesToWorklist(worklist);
  
  while(!worklist.empty()){
     ListNode* current = worklist.front();
     
     Flow* in = 
     mergeFlowFromIncoming(current);
     
     Flow* out = executeFlowFunction(
     	in,current->inst);
     
     for(unsigned int i = 0 ; i < 
     	current->outgoing.size(); i++) {
       
       Flow* new_out = out->join(
       current->outgoing[i]->flow);
     
       if (!(new_out->equals(current
       ->outgoing[i]->flow))){
     
         current->outgoing[i]->f
         low->copy(new_out);
     
         worklist.push(current->
         outgoing[i]->destination);
       }
     }
    worklist.pop();
  }
}
\end{lstlisting}


\input{interface}

\section{Constant Propagation}

\input{constant_propagation}

\section{Available Expressions}

\input{available_expressions}

\section{Range Analysis}

\input{range_analysis}

\section{Pointer Analysis}

\input{pointer_analysis}

\section{Benchmarks}

\input{benchmarks}

\section{Conclusion}

\input{conclusion}

\end{document}
